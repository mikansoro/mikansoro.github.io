<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><meta content="<p>Today, we're taking a look at using IAM roles inside of AWS EKS, leveraging the combined power of IAM Roles for Service Accounts (IRSA) and role chaining inside of AWS config files.</p>
" name=description><title>AWS IAM Role Chaining using IAM Roles for Service Accounts inside Kubernetes</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#ff7f27;--primary-pale-color:#ff7f2710;--text-color:#3c4043;--text-pale-color:#929ab0;--bg-color:#eee;--highlight-mark-color:#5f75b045;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460;--main-font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:750px;--main-max-width:750px;--avatar-size:70px;--paragraph-font-size:16px;--paragraph-line-height:1.75;--aside-font-size:15px;--img-border-radius:0;--inline-code-border-radius:2px}body.dark{--primary-color:#ff7f27;--primary-pale-color:#ff7f2720;--text-color:#9197a5;--text-pale-color:#626975;--bg-color:#202124;--highlight-mark-color:#5f75b045;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}</style><link href=/main.css rel=stylesheet><link href=/hl-light.css id=hl rel=stylesheet><body class=post><script>if(sessionStorage.getItem('theme')=='dark'){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a href=/>mikansoro</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a href=/blog/>blog</a><span class="wrap-separator fold">,</span><a class=fold href=/about/>about</a><span class="wrap-separator fold">,</span><a class=fold href=/blogroll/>blogroll</a><span class="wrap right fold">} ;</span></nav><div id=btns><a aria-label="rss feed" href=/blog//feed.xml><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 17C5.20914 17 7 18.7909 7 21H3V17ZM3 10C9.07513 10 14 14.9249 14 21H12C12 16.0294 7.97056 12 3 12V10ZM3 3C12.9411 3 21 11.0589 21 21H19C19 12.1634 11.8366 5 3 5V3Z" fill=currentColor></path></svg></a><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside class=blur><nav><ul><li><a class=h2 href=#why-does-this-even-matter>Why does this even matter?</a><li><a class=h2 href=#so-a-single-role-isn-t-always-feasible-for-a-pod-have-an-example>So a single role isn't always feasible for a pod. Have an example?</a><li><a class=h2 href=#okay-you-need-to-make-aws-config-profiles-so-that-s-common>Okay, you need to make AWS config profiles. So? That's common.</a><li><a class=h2 href=#how-irsa-works>How IRSA Works</a><li><a class=h2 href=#now-lets-set-up-some-profiles>Now, Lets Set Up Some Profiles</a> <ul><li><a class=h3 href=#bonus-points-kubernetes-best-practices>Bonus Points: Kubernetes Best Practices</a></ul><li><a class=h2 href=#should-i-use-this>Should I use this?</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>AWS IAM Role Chaining using IAM Roles for Service Accounts inside Kubernetes</h1><div id=post-info><div id=date><span id=publish>2024-04-12</span></div><div id=tags><a href=https://mikansoro.org/tags/aws><span>#</span>aws</a><a href=https://mikansoro.org/tags/kubernetes><span>#</span>Kubernetes</a><a href=https://mikansoro.org/tags/eks><span>#</span>eks</a><a href=https://mikansoro.org/tags/iam><span>#</span>iam</a></div></div><p>Today, we're taking a look at using IAM roles inside of AWS EKS, leveraging the combined power of IAM Roles for Service Accounts (IRSA) and role chaining inside of AWS config files.</p><span id=continue-reading></span><blockquote class="callout note"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" fill=currentColor></path></svg></div><div class=content><p><strong>Prerequisites</strong><p>This post assumes the reader has a working understanding of AWS IAM, including the differences between IAM users and roles, how roles are assumed/used, and their purpose in the IAM ecosystem.</div></blockquote><h2 id=why-does-this-even-matter>Why does this even matter?<a aria-label="Anchor link for: why-does-this-even-matter" class=zola-anchor href=#why-does-this-even-matter style=visibility:hidden>#</a></h2><p>I've encountered several instances where a service/job/pod/what-have-you running in an AWS EKS cluster needed to assume multiple AWS roles to accomplish its task. Typically, when a pod needs access to several resources (say, several s3 buckets, an AWS Redshift cluster, and an Athena/Glue crawler in a different account from the EKS cluster), common sense dictates we should create a role specifically for that pod to assume and call it a day. This is a fine pattern, and its a good practice to separate roles meant for assumption by humans from roles meant for robots anyhow.<p>However, there are scenarios where it may not be practical or desirable to create a monolithic role for a specific task. That could be for a myriad of reasons, such as migrating legacy workflows into Kubernetes, using roles that connect to partner/client AWS resources not under your control, or not granting cross-account resource access for roles. Some resources, like AWS Glue and AWS Secrets Manager, don't behave the same way during cross-account access.<h2 id=so-a-single-role-isn-t-always-feasible-for-a-pod-have-an-example>So a single role isn't always feasible for a pod. Have an example?<a aria-label="Anchor link for: so-a-single-role-isn-t-always-feasible-for-a-pod-have-an-example" class=zola-anchor href=#so-a-single-role-isn-t-always-feasible-for-a-pod-have-an-example style=visibility:hidden>#</a></h2><p>Recently, I tried to run an ansible playbook inside a Kubernetes cronjob, while maintaining the playbook's ability to be run by humans (who all use a standardized set of AWS profiles, that's important later). Ideally, both human operators and robots should be able to use the playbook without any code changes. The playbook uses two profiles, named <code>account-a-admin</code> and <code>account-b-admin</code>. All humans who need to run this playbook locally have <code>account-a-admin</code> and <code>account-b-admin</code> profiles defined already in their AWS config file (<code>~/.aws/config</code>), and each profile assumes a role role in either account <code>a</code> or <code>b</code> respectively. These admin roles are powerful, and not something that should be handed out lightly (and never assumed by robots).<p>Now, that still doesn't explain why we can't create new role used solely by this pod, granting the specific access required to execute the playbook. Well, because this playbook operates on ec2 instances, it uses the <code>aws_ec2</code> dynamic inventory plugin. For the inventory plugin to work properly for human users, an AWS profile name must be passed as part of the configuration. Normally, we could override profile names with ansible extra vars (using the <code>-e</code> command line flag) or by using a jinja2 template to look up the value from an environment variable. Sounds simple, right?<p>Wrong. Some dynamic inventory plugins respect extra vars, but are not required to. They also don't support jinja2 templates. You can see where I'm going with this. There isn't a way to dynamically select a profile for the <code>aws_ec2</code> dynamic inventory. Therefore, we need to create AWS config profiles with credentials that will satisfy the inventory plugin.<h2 id=okay-you-need-to-make-aws-config-profiles-so-that-s-common>Okay, you need to make AWS config profiles. So? That's common.<a aria-label="Anchor link for: okay-you-need-to-make-aws-config-profiles-so-that-s-common" class=zola-anchor href=#okay-you-need-to-make-aws-config-profiles-so-that-s-common style=visibility:hidden>#</a></h2><p>That's the impetus behind me writing this. Most engineers who have written AWS config files before have only used them with static credentials stored in <code>~/.aws/credentials</code>, then used those credentials to assume a role. Instead, we can adapt the AWS config with some lesser-known options assume roles granted to pods through EKS, without defining static credentials.<h2 id=how-irsa-works>How IRSA Works<a aria-label="Anchor link for: how-irsa-works" class=zola-anchor href=#how-irsa-works style=visibility:hidden>#</a></h2><p>Now, before we get too deep, here's a brief overview on how IAM integrates with Kubernetes in AWS.<p>At some point, a workload running in Kubernetes will need to access some resource outside the cluster to perform its task. For the sake of example, we'll assume that we have a pod running inside EKS, AWS's cloud Kubernetes distribution. This pod needs to access some files in s3, but it was deemed too risky to stash a non-expiring IAM keypair inside a kubernetes secret and call it a day. Instead, we can grant a pod the temporary credentials required to assume an IAM role through AWS <a rel="nofollow noreferrer" href=https://aws.amazon.com/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/>IAM roles for Service Accounts (IRSA)</a> feature.<p>IRSA works by allowing the exchange of Kubernetes service account OIDC JWT tokens with IAM for set of temporary IAM credentials corresponding to a role. This requires both an <a rel="nofollow noreferrer" href=https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_openid_connect_provider.html>IAM OIDC Connect Provider</a> to be created using the cluster OIDC issuer's URL and thumbprint, and the <a rel="nofollow noreferrer" href=https://github.com/aws/amazon-eks-pod-identity-webhook>eks pod identity mutating admission webhook</a>. When a Kubernetes service account with the <code>eks.amazonaws.com/role-arn: &LTarn></code> annotation is attached to a pod, the pod identity webhook injects a token via a projected <code>serviceAccountToken</code> volume and sets several environment variables.<p>With this token, the pod can then call the AWS SecurityTokenService (STS) api to exchange the the token for a set of IAM credentials, using the <code>AssumeroleWithWebIdentity</code> action. Modern versions of the AWS SDK will see the <code>AWS_WEB_IDENTITY_TOKEN_FILE</code> environment variable and automatically assume the role on startup. For instance, the AWS cli command <code>aws sts get-caller-identity</code> will return a role session for the role specified in the service account annotation instead of a role session for the underlying host node role when the service account is attached.<p>To illustrate what is added by the pod identity webhook, see the following diff.<pre class="language-diff z-code" data-lang=diff><code class=language-diff data-lang=diff><span class="z-source z-diff">apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/svc-eks-podrole
  name: my-serviceaccount
  namespace: default
<span class="z-meta z-separator z-diff"><span class="z-punctuation z-definition z-separator z-diff">---</span>
</span>apiVersion: apps/v1
kind: Pod
metadata:
  name: myapp
spec:
  serviceAccountName: my-serviceaccount
  containers:
  - name: myapp
    image: myapp:1.2
<span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    env:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    - name: AWS_ROLE_ARN
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      value: arn:aws:iam::123456789012:role/svc-eks-podrole
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    - name: AWS_WEB_IDENTITY_TOKEN_FILE
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      value: /var/run/secrets/eks.amazonaws.com/serviceaccount/token
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    volumeMounts:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    - mountPath: /var/run/secrets/eks.amazonaws.com/serviceaccount
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>        name: aws-iam-token
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>        readOnly: true
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>  volumes:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>  - name: aws-iam-token
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    projected:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      defaultMode: 420
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      sources:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      - serviceAccountToken:
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>          audience: sts.amazonaws.com
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>          expirationSeconds: 86400
</span><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>          path: token
</span></span></code></pre><h2 id=now-lets-set-up-some-profiles>Now, Lets Set Up Some Profiles<a aria-label="Anchor link for: now-lets-set-up-some-profiles" class=zola-anchor href=#now-lets-set-up-some-profiles style=visibility:hidden>#</a></h2><p>Now, we've established that role credentials provided thorugh the EKS pod identity webhook are WebIdentity roles, and credentials are granted through the <code>AssumeroleWithWebIdentity</code> STS api. While the AWS SDK and cli will automatically detect the environment variable and assume the role, that does not extend to profiles. For example, if we call <code>aws sts get-caller-identity --profile default</code> from within our EKS pod, the command will exit with an error that no config profile was found with the name "default". Which makes sense, since we haven't defined one in the config file yet.<p>Digging through the <a rel="nofollow noreferrer" href=https://awscli.amazonaws.com/v2/documentation/api/latest/topic/config-vars.html>AWS cli config reference</a>, there's a section for options relating to AssumeroleWithWebIdentity. We can create a profile that takes a web identity token file and role arn, and the SDK will automatically call STS on our behalf to retrieve credentials for the role. Since our token is automatically injected into the pod using a volume and because we know the mount path, this config becomes pretty trivial.<pre class="language-conf z-code" data-lang=conf><code class=language-conf data-lang=conf><span class="z-source z-genconfig"><span class="z-meta z-comment z-genconfig"><span class="z-comment z-line z-number-sign z-genconfig"># In ~/.aws/config
</span></span><span class="z-storage z-type z-genconfig">[profile default]
</span><span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">role_arn</span><span class="z-keyword z-operator z-genconfig">=</span></span>arn<span class="z-keyword z-operator z-genconfig">:</span>aws<span class="z-keyword z-operator z-genconfig">:</span>iam<span class="z-keyword z-operator z-genconfig">:</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-constant z-numeric z-genconfig">123456789012</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-support z-type z-genconfig">role/svc-eks-podrole</span>
<span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">web_identity_token_file</span><span class="z-keyword z-operator z-genconfig">=</span></span><span class="z-keyword z-operator z-genconfig">/</span>var<span class="z-keyword z-operator z-genconfig">/</span>run<span class="z-keyword z-operator z-genconfig">/</span>secrets<span class="z-keyword z-operator z-genconfig">/</span>eks<span class="z-keyword z-operator z-genconfig">.</span>amazonaws<span class="z-keyword z-operator z-genconfig">.</span>com<span class="z-keyword z-operator z-genconfig">/</span>serviceaccount<span class="z-keyword z-operator z-genconfig">/</span>token
</span></code></pre><p>Now, calling <code>aws sts get-caller-identity --profile default</code> will produce the same result as not providing a profile. We're now assuming the role the same as the SDK does without a config file, but in a more explicit way.<p>We can take this a couple steps further though, and chain several role assumptions together. This unlocks a tremendous amount of power when working with multiple roles:<pre class="language-conf z-code" data-lang=conf><code class=language-conf data-lang=conf><span class="z-source z-genconfig"><span class="z-meta z-comment z-genconfig"><span class="z-comment z-line z-number-sign z-genconfig"># In ~/.aws/config
</span></span><span class="z-storage z-type z-genconfig">[profile default]
</span><span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">role_arn</span> <span class="z-keyword z-operator z-genconfig">=</span></span> arn<span class="z-keyword z-operator z-genconfig">:</span>aws<span class="z-keyword z-operator z-genconfig">:</span>iam<span class="z-keyword z-operator z-genconfig">:</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-constant z-numeric z-genconfig">123456789012</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-support z-type z-genconfig">role/svc-eks-podrole</span>
<span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">web_identity_token_file</span> <span class="z-keyword z-operator z-genconfig">=</span></span> <span class="z-keyword z-operator z-genconfig">/</span>var<span class="z-keyword z-operator z-genconfig">/</span>run<span class="z-keyword z-operator z-genconfig">/</span>secrets<span class="z-keyword z-operator z-genconfig">/</span>eks<span class="z-keyword z-operator z-genconfig">.</span>amazonaws<span class="z-keyword z-operator z-genconfig">.</span>com<span class="z-keyword z-operator z-genconfig">/</span>serviceaccount<span class="z-keyword z-operator z-genconfig">/</span>token

<span class="z-storage z-type z-genconfig">[profile account-a-admin]
</span><span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">source_profile</span> <span class="z-keyword z-operator z-genconfig">=</span></span> default
<span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">role_arn</span> <span class="z-keyword z-operator z-genconfig">=</span></span> arn<span class="z-keyword z-operator z-genconfig">:</span>aws<span class="z-keyword z-operator z-genconfig">:</span>iam<span class="z-keyword z-operator z-genconfig">:</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-constant z-numeric z-genconfig">345678901234</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-support z-type z-genconfig">role/Administrator-role</span> 

<span class="z-storage z-type z-genconfig">[profile account-b-admin]
</span><span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">source_profile</span> <span class="z-keyword z-operator z-genconfig">=</span></span> default
<span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">role_arn</span> <span class="z-keyword z-operator z-genconfig">=</span></span> arn<span class="z-keyword z-operator z-genconfig">:</span>aws<span class="z-keyword z-operator z-genconfig">:</span>iam<span class="z-keyword z-operator z-genconfig">:</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-constant z-numeric z-genconfig">567890123456</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-support z-type z-genconfig">role/Administrator-role</span> 

<span class="z-storage z-type z-genconfig">[profile account-b-specialized]
</span><span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">source_profile</span> <span class="z-keyword z-operator z-genconfig">=</span></span> account<span class="z-keyword z-operator z-genconfig">-</span>b<span class="z-keyword z-operator z-genconfig">-</span>admin
<span class="z-meta z-param z-genconfig"><span class="z-variable z-parameter z-genconfig">role_arn</span> <span class="z-keyword z-operator z-genconfig">=</span></span> arn<span class="z-keyword z-operator z-genconfig">:</span>aws<span class="z-keyword z-operator z-genconfig">:</span>iam<span class="z-keyword z-operator z-genconfig">:</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-constant z-numeric z-genconfig">567890123456</span><span class="z-keyword z-operator z-genconfig">:</span><span class="z-support z-type z-genconfig">role/special-s3-access</span> 
</span></code></pre><p>If we call <code>aws sts get-caller-identity --profile account-b-specialized</code> now, the AWS SDK will automatically chain the assumption of all three roles and return a set of credentials matching the <code>arn:aws:iam::567890123456:role/special-s3-access</code> role. Not only that, but the SDK now has a template on how to automatically refresh these role credentials when they're close to expiring, without having to call STS ourselves or write any code that creates or manages AWS sessions.<h3 id=bonus-points-kubernetes-best-practices>Bonus Points: Kubernetes Best Practices<a aria-label="Anchor link for: bonus-points-kubernetes-best-practices" class=zola-anchor href=#bonus-points-kubernetes-best-practices style=visibility:hidden>#</a></h3><p>Instead of injecting this AWS config into your container at build time, create a Kubernetes configmap with the AWS config and mount it inside the pod using a volume. Commit these manifests to your kubernetes source control repository (you have one, don't you?), that way other engineers very explicitly know what roles are being consumed by this particular workload, and they can be easily adapted down the line.<h2 id=should-i-use-this>Should I use this?<a aria-label="Anchor link for: should-i-use-this" class=zola-anchor href=#should-i-use-this style=visibility:hidden>#</a></h2><p>Ultimately, that comes down to your use case and the organization you work in. If your code (script in a cronjob, Airflow DAG, web microservice, etc) can operate off of a single AWS role that can be directly assumed by the pod, then no, don't bother. Continue using web identity role assumption directly through the SDK as you have been and move on with life.<p>If you need multiple roles for different actions, run with an ancient SDK, or need to maintain code execution compatibility between different types of systems as I had, then this might be an easy solution. Sure, it's possible to write some code against boto3 to assume multiple roles and auto-refresh their credentials before every operation if they're close to expiring. You can gate that code to only running in specific execution environments too. Or, you can offload all that work (and brittleness) to the AWS SDK, and let it do its job handling credentials for you.<p>Put it this way, do you really want to be parsing temp files to check the credential expiry time with <code>jq</code> every time your bash script needs to connect to s3, and renew them if they're close to expiring? I certainly wouldn't.</article></div><footer><div class=copyright><p>© 2023 mikansoro</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>